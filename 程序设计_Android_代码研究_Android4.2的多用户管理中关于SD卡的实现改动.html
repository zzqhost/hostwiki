<html>
  <head>
    <title>Android4.2的多用户管理中关于SD卡的实现改动=</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="Stylesheet" type="text/css" href="cssandjs/style.css" />
</head>


<body>


<div id="container">
    <div id="header">张志强的wiki</div>
    <br class="clearfloat" />
    <div id="content">
<p>
<a href="首页.html">首页</a>
</p>

<h1 id="toc_1"> Android4.2的多用户管理中关于SD卡的实现改动</h1>
<div class="toc">
<ul>
<li><a href="#toc_1"> Android4.2的多用户管理中关于SD卡的实现改动</a>
<ul>
<li><a href="#toc_1.1">1. 问题</a>
<li><a href="#toc_1.2">2. Android4.2中对SD卡Mount的实现</a>
<ul>
<li><a href="#toc_1.2.1">2.1. 在init.rc中创建挂载点路径,及定义环境变量</a>
<li><a href="#toc_1.2.2">2.2. 进程内的不共享的挂载点</a>
</ul>
<li><a href="#toc_1.3">3. 多用户访问SD卡实现模式</a>
<li><a href="#toc_1.4">4. 遗留问题</a>
<li><a href="#toc_1.5">5. 最终答案</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">1. 问题</h2>
<ul>
<li>
Android4.2中,通过类得到的SD卡路径类似 /storage/emulated/0 在adb shell中看不到,也不能访问.

<li>
MediaServer不能访问这样的路径.　/storage/emulated/0/

<li>
libstagefright中原先可以正常读写的SD卡路径,现在由于以上原因不能用了.

<li>
另外:　还有一个权限问题,本文不进行讨论,但它是现实存在的,由于它的存在,导致即使程序中写死实际的挂载点,它也会提示没有权限.

</ul>

<h2 id="toc_1.2">2. Android4.2中对SD卡Mount的实现</h2>
<h3 id="toc_1.2.1">2.1. 在init.rc中创建挂载点路径,及定义环境变量</h3>
<pre  # See storage config details at &lt;a href="http://source.android.com/tech/storage/"&gt;http://source.android.com/tech/storage/&lt;/a&gt;>
mkdir /mnt/shell/emulated 0700 shell shell
mkdir /storage/emulated 0555 root root
 
export EXTERNAL_STORAGE /storage/emulated/legacy
export EMULATED_STORAGE_SOURCE /mnt/shell/emulated
export EMULATED_STORAGE_TARGET /storage/emulated
 
# Support legacy paths
symlink /storage/emulated/legacy /sdcard
symlink /storage/emulated/legacy /mnt/sdcard
symlink /storage/emulated/legacy /storage/sdcard0
symlink /mnt/shell/emulated/0 /storage/emulated/legacy
</pre>

<ul>
<li>
其中创建的两个如下目录

<ul>
<li>
/mnt/shell/emulated/　是实际要挂载sdcard的目录

<li>
/storage/emulated/ 是每个用户为它们自己挂载sdcard的目录.

</ul>
<li>
SD卡实际挂载到的是 /mnt/shell/emulated/0, 其它的 /storage/emulated/legacy, /sdcard/, /mnt/sdcard/, /storage/emulated/legacy都是它的链接.

</ul>

<h3 id="toc_1.2.2">2.2. 进程内的不共享的挂载点</h3>
<ul>
<li>
linux 内核命名空间,　在Linux 2.6之后引入了一个新的技术 unshare, 它可以使某个应用程序创建的挂载点等不共享,只有自己可见.

<li>
dalvik_system_Zygote.cpp中的mountEmulatedStorage()函数.　会在Zygote创建一个新的java进程时运行,　先应用 unshare , 然后再以 MS_BIND参数把 /mnt/shell/emulated/0 再挂载到 /storage/emulated/0 下.　　   (dalvik/vm/native)

<li>
其中的0是用户ID, 计算方法是 UID/100000, 代码在 system/core/libcutils/multiuser.c中.　　所以在这里的多用户,即是给每个用户一个UID段,　0 即为主用户.　新建的用户往后排. 它们拥有各自的　UID 段.

<li>
在Environment中通过一样的方法计算得到　external storage路径,　即 /storeage/emulated/0.     (/frameworks/base/core/java/android/os)

</ul>

<h2 id="toc_1.3">3. 多用户访问SD卡实现模式</h2>
<ul>
<li>
每个用户拥有各自的应用程序,　第二个用户想安装想同的应用时,　系统会进行模拟安装 (来源自网上介绍文章)

<li>
在应用程序创建时,会创建一个它自己能访问的SD卡挂载点 /storeage/emulated/[userid].

<li>
Mediaserver等不是通过Zygote创建的native程序,　不会创建 /storage/emulated/* 挂载点,所以就不能直接访问应用程序传下来的SD路径.

<li>
adb shell 也不是通过 Zygote 来创建的,　也没有此挂载点,　所以不能访问 /storage/emulated/*

</ul>

<h2 id="toc_1.4">4. 遗留问题</h2>
<ul>
<li>
应用程序创建的 /storage/emulated/0 路径(空路径,未挂载的目录)　为什么通过 adb shell 看不到呢, 通过什么手段隐藏的?

</ul>


<h2 id="toc_1.5">5. 最终答案</h2>
<ul>
<li>
在这里将要解答前面不知道的两个问题

<ul>
<li>
为什么MediaServer会没有读写 /storage/emulated/legacy/的权限呢?

<li>
为什么通过adb shell看不到 /storage/emulated/0 这个目录呢,即使它没有挂载也应该有一个空目录啊?

</ul>
<li>
答案

<ul>
<li>
文件 android4.2/dalvik/vm/Init.cpp 中的　initZygote()　函数
<pre>
static bool initZygote()
{
    /* zygote goes into its own process group */
    setpgid(0,0);

    // See storage config details at http://source.android.com/tech/storage/
    // Create private mount namespace shared by all children
    if (unshare(CLONE_NEWNS) == -1) {
        SLOGE("Failed to unshare(): %s", strerror(errno));
        return -1;
    }

    // Mark rootfs as being a slave so that changes from default
    // namespace only flow into our children.
    if (mount("rootfs", "/", NULL, (MS_SLAVE | MS_REC), NULL) == -1) {
        SLOGE("Failed to mount() rootfs as MS_SLAVE: %s", strerror(errno));
        return -1;
    }

    // Create a staging tmpfs that is shared by our children; they will
    // bind mount storage into their respective private namespaces, which
    // are isolated from each other.
    const char* target_base = getenv("EMULATED_STORAGE_TARGET");
    if (target_base != NULL) {
        if (mount("tmpfs", target_base, "tmpfs", MS_NOSUID | MS_NODEV,
                "uid=0,gid=1028,mode=0050") == -1) {
            SLOGE("Failed to mount tmpfs to %s: %s", target_base, strerror(errno));
            return -1;
        }
    }

    return true;
}
</pre>

<li>
文件android4.2/dalvik/vm/native/dalvik_system_Zygote.cpp的 mountEmulatedStorage(uid_t uid, u4 mountMode)函数,上边已经说了,这里就不再说了.

</ul>
<li>
在上述两个地方主要做了三件事

<ul>
<li>
先调用了一个 unsahre(), 使本进程的mount点不与其它的进程共享.

<li>
再对目录 /storage/emulated/ 做了一个 tmpfs 的挂载. 请参考<a href="Linux系统_学习笔记_tmpfs.html">tmpfs是什么</a>

<li>
然后又以参数MS_BIND调用了mount, 把 /mnt/shell/emulated/0 又挂载到了 /storage/emulated/0/下.

</ul>
<li>
释疑

<ul>
<li>
/mnt/shell/目录的权限是 700, 用户是shell, 一般的进程都不可能是这个用户,所以一般的进程都没有权限对它进行读写.

</ul>
</ul>
</div>
    <br class="clearfloat" />


    <div id="disqus_thread"></div>
    <script type="text/javascript" src="cssandjs/javascript/tongjianddisqus.js"></script>

    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    <div id="footer">
            zzqhost&nbsp;&copy;&nbsp;2012-2013&nbsp;
            <a href="http://www.zzqhost.com" target="_blank">www.zzqhost.com</a>
            <br>
            Generated by
            <a href="http://www.vim.org" target="_blank">Vim</a>
            &amp;
            <a href="http://code.google.com/p/vimwiki/" target="_blank">Vimwiki</a>
    </div>

</div>

</body>
</html>
